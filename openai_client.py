from typing import List, Optional

import openai
from googleapiclient.discovery import build

from helpers import clean_text
from urllib.request import urlopen
from urllib.error import URLError
from bs4 import BeautifulSoup

class OpenAIClient:
    def __init__(self, api_token, google_search_api_token, google_search_cse_id, engine="davinci"):
        assert api_token, "You must give an OpenAI API token"
        assert google_search_api_token, "You must give a Google Search API token"
        assert google_search_cse_id, "You must give a Google Search CSE ID"
        openai.api_key = api_token
        self._engine = engine
        self._google_search_cse_id = google_search_cse_id
        self._google_search = build(
            "customsearch", "v1", developerKey=google_search_api_token).cse()

    def _superior_intelligence_prefix(self, topic: str) -> str:
        return f"""Below is a long paragraph generated by a superior intelligence, which sees the human world from the outside, without the prejudices of human experience. Fully neutral and objective, the being sees the world as is. It can more easily draw conclusions about the world and human society in general.
The topic provided by the human is '{topic}', to which the individual responds with deep thought."""

    def call_completion(self,
                        prompt: str,
                        stop: Optional[List[str]] = ["\"\n", "\n\n\n", "\n\""],
                        max_tokens: int = 100,
                        max_tries: int = 5,
                        ):
        """

        :param max_tries:
        :param max_tokens:
        :param stop:
        :param prompt:
        :return:
        """

        tries = 0
        print(f"call_completion with prompt {prompt}")
        while tries < max_tries:
            print(f"try nÂ°{tries}/{max_tries}")
            response = openai.Completion.create(
                engine="davinci",
                prompt=prompt,
                temperature=0.7,
                max_tokens=max_tokens,
                top_p=1,
                frequency_penalty=1,
                presence_penalty=1,
                stop=stop,
                best_of=1,
            )
            choices = response.get("choices")
            print(response)
            if not choices \
                    or not isinstance(choices, list) \
                    or len(choices) == 0 \
                    or not choices[0].get("text"):
                tries += 1
                continue
            response = choices[0].get("text")
            response = clean_text(response)
            return response
        return None

    def openai_description(self, topic: str) -> Optional[str]:
        """
        returns openai generated description or None
        :param topic:
        :return:
        """

        description = f"""
{self._superior_intelligence_prefix(topic)}
Genius: "Hmmm, interesting topic. Here is my rather lengthy description of it:"
        """

        print(f"calling openai_description with prompt {description}")
        description = self.call_completion(
            description, stop=["Genius:", "Human:", "\"\n", "\n\n\n"])
        return description

    def wikipedia_description(self, topic: str) -> Optional[str]:
        """
        returns wikipedia description or None
        :param topic:
        :return:
        """
        search = self._google_search\
            .list(q=f"wikipedia {topic}", cx=self._google_search_cse_id, num=1)\
            .execute()
        items = search.get("items")
        if not items or len(items) == 0 or not items[0].get("link"):
            return None

        try:
            html = urlopen(items[0].get("link"))
        except URLError:
            # Rate limited
            return None
        soup = BeautifulSoup(html, "html.parser")
        short_description = soup.find("div", {"class": "shortdescription"})
        if not short_description:
            return None
        return short_description.text

    
    def generate(self,
                 topic: str,
                 ) -> Optional[str]:
        """
        Generate meme using OpenAI API
        :param topic:
        :return:
        """
        basic_stops = ["\"\n", "\n\n\n", "Genius:", "?"]

        def prompt(p: str):
            return f"""
{self._superior_intelligence_prefix(p)}
Genius: "Hmmm, an interesting topic. Here are the most important questions of this theme that humanity is facing today:"
            """

        def prompt_synonymous(p: str):
            return f"I will present the topic of '{p}' as the following:"

        meme_text = self.call_completion(
            prompt=prompt(topic), stop=basic_stops, max_tokens=500)

        if not meme_text:
            print(f"Could not generate a meme for topic {topic}")
            return None

        return meme_text
